# Story 1.3: K-Means Market Segmentation

## Status: Draft

## Assigned To: Mario

## Story

**As a** pricing analyst,
**I want** market contexts automatically segmented into distinct clusters,
**so that** I can understand different pricing contexts.

## Acceptance Criteria

1. K-Means clustering implemented in `backend/src/ml/segmenter.py` using scikit-learn
2. Optimal k determined using elbow method or silhouette score (document choice)
3. Features selected and scaled appropriately (StandardScaler)
4. Each cluster labeled with descriptive name (e.g., "Urban_Peak_Premium")
5. Cluster centroids stored for assignment of new contexts
6. Function `classify(context: MarketContext) -> SegmentResult` to assign new contexts
7. Segment distribution visualized and saved as reference data

## Tasks / Subtasks

- [ ] Task 1: Create segmenter module structure (AC: 1)
  - [ ] Create `backend/src/ml/segmenter.py`
  - [ ] Import scikit-learn KMeans, StandardScaler
  - [ ] Create `Segmenter` class with `fit()` and `classify()` methods

- [ ] Task 2: Implement feature selection and scaling (AC: 3)
  - [ ] Select features: supply_demand_ratio, time_of_booking_encoded, location_encoded, vehicle_type_encoded
  - [ ] Implement StandardScaler for feature normalization
  - [ ] Create feature preprocessing pipeline

- [ ] Task 3: Determine optimal k (AC: 2)
  - [ ] Implement elbow method analysis
  - [ ] Implement silhouette score calculation
  - [ ] Document chosen k value and rationale (expect ~6 segments)
  - [ ] Save analysis results

- [ ] Task 4: Train and label clusters (AC: 4, 5)
  - [ ] Train K-Means with optimal k
  - [ ] Generate descriptive labels based on cluster centroids
  - [ ] Create label mapping (e.g., cluster 0 → "Urban_Peak_Premium")
  - [ ] Store centroids for later classification

- [ ] Task 5: Implement classification function (AC: 6)
  - [ ] Create `classify(context: MarketContext) -> SegmentResult` method
  - [ ] Scale incoming context using fitted scaler
  - [ ] Return segment name, cluster ID, characteristics, centroid distance

- [ ] Task 6: Save model and reference data (AC: 7)
  - [ ] Save model to `backend/data/models/segmenter.joblib`
  - [ ] Save segment distribution as reference JSON
  - [ ] Create model loading utility

- [ ] Task 7: Write unit tests
  - [ ] Test segmenter fitting
  - [ ] Test classification returns valid segment
  - [ ] Test model persistence

## Dev Notes

### Segmenter Architecture (from docs/architecture/components.md)
```python
class Segmenter:
    def __init__(self, n_clusters: int = 6):
        self.kmeans = KMeans(n_clusters=n_clusters, random_state=42)
        self.scaler = StandardScaler()
        self.segment_labels = {}
    
    def fit(self, data: pd.DataFrame) -> None:
        """Train segmenter on historical data"""
        
    def classify(self, context: MarketContext) -> SegmentResult:
        """Assign market context to segment"""
        return SegmentResult(
            segment_name="Urban_Peak_Premium",
            cluster_id=0,
            characteristics={"avg_surge": 1.8},
            centroid_distance=0.23  # confidence indicator
        )
```

### Expected Segments (~6 based on Location × Vehicle combinations)
- Urban_Peak_Premium
- Urban_Standard_Economy
- Suburban_Peak_Premium
- Suburban_Standard_Economy
- Rural_Peak_Premium
- Rural_Standard_Economy

### Model Persistence
- Location: `backend/data/models/segmenter.joblib`
- Use joblib for serialization

### Feature Engineering
Features to use for clustering:
- supply_demand_ratio (derived)
- Time_of_Booking (encoded)
- Location_Category (encoded)
- Vehicle_Type (encoded)

### Testing

- Test file: `backend/tests/unit/test_ml/test_segmenter.py`
- Test that classify returns valid SegmentResult
- Test model can be saved and loaded
- Test centroid distance is positive

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-02 | 1.0 | Initial story creation | SM Agent |

## Dev Agent Record

### Agent Model Used
(To be filled by Dev Agent)

### Debug Log References
(To be filled by Dev Agent)

### Completion Notes List
(To be filled by Dev Agent)

### File List
(To be filled by Dev Agent)

## QA Results
(To be filled by QA Agent)

