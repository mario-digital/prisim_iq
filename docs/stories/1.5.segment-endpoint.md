# Story 1.5: Segment Assignment Endpoint

## Status: Draft

## Assigned To: Mario

## Story

**As a** pricing analyst,
**I want** to submit a market context and receive its segment assignment,
**so that** I can understand which pricing cluster applies.

## Acceptance Criteria

1. `POST /api/v1/data/segment` endpoint accepts MarketContext in request body
2. Returns: segment name, cluster ID, segment characteristics, centroid distance (confidence)
3. Returns distance to centroid as confidence indicator (lower = more confident)
4. Validates input with Pydantic, returns 422 with field errors for invalid data
5. Includes human-readable segment description in response
6. Response time < 100ms for segment classification

## Tasks / Subtasks

- [ ] Task 1: Create MarketContext schema (AC: 1, 4)
  - [ ] Create `backend/src/schemas/market.py`
  - [ ] Define MarketContext Pydantic model with all required fields
  - [ ] Add field validators for ranges and enums
  - [ ] Add example values for Swagger docs

- [ ] Task 2: Create SegmentDetails response schema (AC: 2, 3, 5)
  - [ ] Create `backend/src/schemas/segment.py`
  - [ ] Define SegmentDetails with segment_name, cluster_id, characteristics
  - [ ] Add centroid_distance field
  - [ ] Add human_readable_description field

- [ ] Task 3: Implement segment endpoint (AC: 1, 2, 6)
  - [ ] Add segment route to `backend/src/api/routers/data.py`
  - [ ] Implement `POST /api/v1/data/segment`
  - [ ] Wire up Segmenter from Story 1.3
  - [ ] Return SegmentDetails response

- [ ] Task 4: Add segment descriptions (AC: 5)
  - [ ] Create description mapping for each segment
  - [ ] Generate contextual descriptions based on characteristics
  - [ ] Example: "High-demand urban area during peak hours with premium vehicle preference"

- [ ] Task 5: Add validation error handling (AC: 4)
  - [ ] Ensure 422 returned for invalid input
  - [ ] Include field-level error details
  - [ ] Test validation with edge cases

- [ ] Task 6: Performance optimization (AC: 6)
  - [ ] Ensure classification < 100ms
  - [ ] Add timing logs
  - [ ] Consider caching scaler/model

- [ ] Task 7: Write tests
  - [ ] Test valid segment classification
  - [ ] Test 422 for invalid input
  - [ ] Test response time < 100ms

## Dev Notes

### MarketContext Schema (from docs/architecture/data-models.md)
```python
class MarketContext(BaseModel):
    number_of_riders: int = Field(ge=1, le=100, description="Demand indicator")
    number_of_drivers: int = Field(ge=1, le=100, description="Supply indicator")
    location_category: Literal["Urban", "Suburban", "Rural"]
    customer_loyalty_status: Literal["Bronze", "Silver", "Gold", "Platinum"]
    number_of_past_rides: int = Field(ge=0)
    average_ratings: float = Field(ge=1.0, le=5.0)
    time_of_booking: Literal["Morning", "Afternoon", "Evening", "Night"]
    vehicle_type: Literal["Economy", "Premium"]
    expected_ride_duration: int = Field(ge=1, description="Minutes")
    historical_cost_of_ride: float = Field(ge=0, description="Baseline price")
    
    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "number_of_riders": 50,
                "number_of_drivers": 25,
                "location_category": "Urban",
                "customer_loyalty_status": "Gold",
                "number_of_past_rides": 20,
                "average_ratings": 4.5,
                "time_of_booking": "Evening",
                "vehicle_type": "Premium",
                "expected_ride_duration": 30,
                "historical_cost_of_ride": 35.0
            }
        }
    )
```

### SegmentDetails Response Schema
```python
class SegmentDetails(BaseModel):
    segment_name: str  # e.g., "Urban_Peak_Premium"
    cluster_id: int
    characteristics: dict[str, Any]  # {"avg_surge": 1.8, "typical_duration": 25}
    centroid_distance: float  # Lower = more confident
    human_readable_description: str  # "High-demand urban area..."
    confidence_level: Literal["high", "medium", "low"]  # Based on distance
```

### Endpoint Implementation
```python
@router.post("/segment", response_model=SegmentDetails)
async def classify_segment(context: MarketContext) -> SegmentDetails:
    segmenter = get_segmenter()  # From dependencies
    result = segmenter.classify(context)
    return result
```

### Performance Target
- Classification must complete in < 100ms
- Model should be loaded once at startup, not per-request

### Testing

- Test file: `backend/tests/integration/test_api/test_segment.py`
- Test valid classification returns SegmentDetails
- Test invalid input returns 422 with field errors
- Test performance with timing assertions

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-02 | 1.0 | Initial story creation | SM Agent |

## Dev Agent Record

### Agent Model Used
(To be filled by Dev Agent)

### Debug Log References
(To be filled by Dev Agent)

### Completion Notes List
(To be filled by Dev Agent)

### File List
(To be filled by Dev Agent)

## QA Results
(To be filled by QA Agent)

