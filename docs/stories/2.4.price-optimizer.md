# Story 2.4: Price Optimization Loop

## Status: Ready for Review

## Assigned To: Mario

## Story

**As a** pricing analyst,
**I want** the system to find the profit-maximizing price,
**so that** I receive optimal recommendations.

## Acceptance Criteria

1. Optimization function in `backend/src/ml/price_optimizer.py`
2. Objective: Maximize `(price - cost) * predicted_demand(price)`
3. Price bounds configurable (default: $5 min, $200 max from Settings)
4. Returns: `optimal_price`, `expected_demand`, `expected_profit`, `profit_vs_baseline`
5. Baseline comparison using static historical price
6. Optimization completes in < 500ms per context
7. Unit tests verify optimizer finds known optimal on synthetic data

## Tasks / Subtasks

- [x] Task 1: Create optimizer module (AC: 1)
  - [x] Create `backend/src/ml/price_optimizer.py`
  - [x] Create `PriceOptimizer` class
  - [x] Inject ModelManager dependency

- [x] Task 2: Implement objective function (AC: 2)
  - [x] Define profit function: `(price - cost) * demand`
  - [x] Create wrapper that calls model for demand prediction
  - [x] Handle negative profit scenarios

- [x] Task 3: Implement optimization loop (AC: 3, 6)
  - [x] Use grid search at $0.50 increments within bounds
  - [x] Or use scipy.optimize.minimize_scalar for faster convergence
  - [x] Configurable price bounds (default $5 - $200)
  - [x] Ensure < 500ms execution time

- [x] Task 4: Create optimization result (AC: 4)
  - [x] Return `OptimizationResult` dataclass/Pydantic model
  - [x] Include: optimal_price, expected_demand, expected_profit
  - [x] Include: price_demand_curve data for visualization

- [x] Task 5: Implement baseline comparison (AC: 5)
  - [x] Calculate profit at historical_cost_of_ride
  - [x] Calculate profit_uplift_percent
  - [x] Include in result

- [x] Task 6: Add caching (AC: 6)
  - [x] LRU cache for identical contexts
  - [x] Cache key based on context hash
  - [x] Configurable cache size

- [x] Task 7: Write tests (AC: 7)
  - [x] Test optimizer finds known optimal
  - [x] Test execution time < 500ms
  - [x] Test returns valid OptimizationResult

## Dev Notes

### Optimization Approach
```python
# Grid Search (simple, reliable)
def optimize_price(context: MarketContext) -> OptimizationResult:
    cost = context.historical_cost_of_ride
    prices = np.arange(5.0, 200.0, 0.50)  # $0.50 increments
    
    best_profit = -float('inf')
    best_price = cost
    
    for price in prices:
        demand = model_manager.predict(context, price)
        profit = (price - cost) * demand
        if profit > best_profit:
            best_profit = profit
            best_price = price
            best_demand = demand
    
    return OptimizationResult(
        optimal_price=best_price,
        expected_demand=best_demand,
        expected_profit=best_profit,
        ...
    )
```

### OptimizationResult Schema
```python
class OptimizationResult(BaseModel):
    optimal_price: float
    expected_demand: float
    expected_profit: float
    baseline_price: float
    baseline_profit: float
    profit_uplift_percent: float  # (optimal - baseline) / baseline * 100
    price_demand_curve: list[dict]  # For visualization
    optimization_time_ms: float
```

### Price-Demand Curve Data
```python
# For visualization - sample at key points
price_demand_curve = [
    {"price": 10.0, "demand": 0.95, "profit": 4.75},
    {"price": 20.0, "demand": 0.85, "profit": 12.75},
    {"price": 30.0, "demand": 0.70, "profit": 14.00},  # Optimal
    {"price": 40.0, "demand": 0.50, "profit": 10.00},
    {"price": 50.0, "demand": 0.30, "profit": 6.00},
]
```

### Caching Strategy
```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def _cached_optimize(context_hash: str) -> OptimizationResult:
    ...

def optimize(context: MarketContext) -> OptimizationResult:
    context_hash = hash_context(context)
    return _cached_optimize(context_hash)
```

### Testing

- Test file: `backend/tests/unit/test_ml/test_price_optimizer.py`
- Test with known synthetic data where optimal is calculable
- Test performance: `assert optimization_time_ms < 500`
- Test profit_uplift_percent calculation

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-02 | 1.0 | Initial story creation | SM Agent |
| 2025-01-02 | 1.1 | Implemented price optimizer with all ACs, 20 tests added | Dev Agent |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (via Cursor)

### Debug Log References
- `pytest tests/unit/test_ml/test_price_optimizer.py -v` → 20 passed
- `pytest tests/ -v` → 164 passed, 4 warnings (sklearn feature name warnings, benign)

### Completion Notes List
- Created `PriceOptimizer` class with ModelManager DI
- Implemented grid search at configurable step size ($0.50 default)
- Added `OptimizationResult` Pydantic schema with all required fields
- Added price bounds settings to `config.py` (price_min=5.0, price_max=200.0, price_step=0.50)
- Implemented LRU-style cache with MD5 context hashing and configurable size
- Baseline comparison uses historical_cost_of_ride for profit_uplift_percent
- Test verifies optimizer finds known optimal with mock demand function
- Performance test confirms < 500ms execution

### File List
| File | Action |
|------|--------|
| `backend/src/ml/price_optimizer.py` | Created |
| `backend/src/schemas/optimization.py` | Created |
| `backend/src/config.py` | Modified (added price_min, price_max, price_step, optimization_cache_size) |
| `backend/src/schemas/__init__.py` | Modified (export OptimizationResult, PriceDemandPoint) |
| `backend/src/ml/__init__.py` | Modified (export PriceOptimizer, get_price_optimizer) |
| `backend/tests/unit/test_ml/test_price_optimizer.py` | Created |

## QA Results

### Review Date: 2025-01-02

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent implementation** with clean architecture, proper dependency injection, comprehensive testing, and performance optimization through caching.

**Strengths:**
- Clean DI pattern with `ModelManager` injection enabling testability
- Singleton pattern via `get_price_optimizer()` for application-wide use
- Well-documented code with type hints throughout
- LRU-style cache with configurable size and proper eviction
- Grid search optimization with configurable step size ($0.50 default)
- Handles edge cases (negative profit → 0, below-cost prices)

**Code Organization:**
- `PriceOptimizer` class: 260 lines, well-structured with clear method separation
- `OptimizationResult` schema: 33 lines, proper Pydantic validation
- Test file: 540 lines, comprehensive coverage across 4 test classes

### Refactoring Performed

- **File**: `backend/src/ml/price_optimizer.py`
  - **Change**: Removed unused `lru_cache` import
  - **Why**: Import was never used (custom cache implementation was chosen)
  - **How**: Deleted line `from functools import lru_cache`

- **File**: `backend/tests/unit/test_ml/test_price_optimizer.py`
  - **Change**: Fixed whitespace in docstring, updated mock function signature, removed unused variable
  - **Why**: Linting errors (W293, ARG001, F841)
  - **How**: Converted mock function to use keyword-only arguments with `noqa` comment for intentionally unused params

### Compliance Check

- Coding Standards: ✓ Follows Python standards (snake_case, docstrings, type hints)
- Project Structure: ✓ Files in correct locations per unified-project-structure
- Testing Strategy: ✓ Unit tests with proper mocking, fixture usage, test isolation
- All ACs Met: ✓ All 7 acceptance criteria fully implemented and tested

### Improvements Checklist

- [x] Removed unused `lru_cache` import (price_optimizer.py)
- [x] Fixed linting issues in test file (whitespace, unused args/vars)
- [ ] Consider adding integration test for optimizer with actual model (nice-to-have)
- [ ] Consider scipy.optimize.minimize_scalar as alternative to grid search (mentioned in Dev Notes, not implemented - acceptable trade-off for simplicity)

### Security Review

No security concerns identified. Module handles numerical computations only, no user input validation concerns, no external data access.

### Performance Considerations

- ✅ Grid search at $0.50 increments over $5-$200 range = ~390 iterations per optimization
- ✅ LRU cache prevents redundant computations for identical contexts
- ✅ Performance test confirms < 500ms execution (typically ~1-2ms with mock models)
- ✅ Cache eviction works correctly when size limit reached

### Files Modified During Review

| File | Action |
|------|--------|
| `backend/src/ml/price_optimizer.py` | Modified (removed unused import) |
| `backend/tests/unit/test_ml/test_price_optimizer.py` | Modified (lint fixes) |

**Dev**: Please update File List to reflect these modifications.

### Requirements Traceability

| AC | Description | Test Coverage | Status |
|----|-------------|---------------|--------|
| AC1 | Optimization function in price_optimizer.py | `test_optimizer_initialization`, `test_optimize_returns_result` | ✅ PASS |
| AC2 | Maximize (price - cost) * demand | `test_compute_profit_*` (3 tests) | ✅ PASS |
| AC3 | Configurable price bounds | `test_optimizer_with_custom_settings` | ✅ PASS |
| AC4 | Returns required fields | `test_optimize_returns_result`, `test_optimize_price_demand_curve` | ✅ PASS |
| AC5 | Baseline comparison | `test_optimize_profit_uplift_calculation` | ✅ PASS |
| AC6 | < 500ms execution | `test_optimize_execution_time` | ✅ PASS |
| AC7 | Tests verify known optimal | `test_finds_optimal_with_mock_model` | ✅ PASS |

### Gate Status

Gate: PASS → docs/qa/gates/2.4-price-optimizer.yml

### Recommended Status

✓ **Ready for Done**

All acceptance criteria met, all tests passing (20/20), lint clean, no blocking issues.

