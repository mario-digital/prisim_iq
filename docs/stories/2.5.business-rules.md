# Story 2.5: Business Rules Layer

## Status: Draft

## Assigned To: Mario

## Story

**As a** compliance officer,
**I want** business rules applied to model-optimal prices,
**so that** recommendations comply with policy.

## Acceptance Criteria

1. Rules engine implemented in `backend/src/rules/engine.py`
2. Rules loaded from `backend/src/rules/config.yaml`
3. **Price Caps:** Max surge multiplier by segment/vehicle (default 3.0x)
4. **Price Floors:** Minimum price ensuring positive margin
5. **Fairness Constraints:** Surge caps for vulnerable segments
6. **FAR Compliance:** Government pricing rules (if applicable)
7. **Loyalty Discounts:** Tier-based discounts (Bronze 0%, Silver 5%, Gold 10%, Platinum 15%)
8. Rules applied in priority order, each application logged
9. Final price returned with list of rules triggered and their impact

## Tasks / Subtasks

- [ ] Task 1: Create rules engine structure (AC: 1)
  - [ ] Create `backend/src/rules/__init__.py`
  - [ ] Create `backend/src/rules/engine.py`
  - [ ] Create `RulesEngine` class

- [ ] Task 2: Create rules configuration (AC: 2)
  - [ ] Create `backend/src/rules/config.yaml`
  - [ ] Define rule schema with conditions and actions
  - [ ] Add priority ordering

- [ ] Task 3: Implement price cap rules (AC: 3)
  - [ ] Max surge multiplier rule (default 3.0x historical cost)
  - [ ] Segment-specific caps (Urban can go higher than Rural)
  - [ ] Vehicle-specific caps (Premium allows higher surge)

- [ ] Task 4: Implement price floor rules (AC: 4)
  - [ ] Minimum price = cost + minimum_margin
  - [ ] Configurable minimum margin (default 10%)
  - [ ] Never recommend below cost

- [ ] Task 5: Implement fairness constraints (AC: 5)
  - [ ] Identify vulnerable segments (Rural, low loyalty)
  - [ ] Apply stricter surge caps (e.g., 1.5x max)
  - [ ] Log fairness rule applications

- [ ] Task 6: Implement loyalty discounts (AC: 7)
  - [ ] Bronze: 0% discount
  - [ ] Silver: 5% discount
  - [ ] Gold: 10% discount
  - [ ] Platinum: 15% discount
  - [ ] Apply after all other rules

- [ ] Task 7: Create rule application result (AC: 8, 9)
  - [ ] Track each rule applied
  - [ ] Calculate impact (before/after for each rule)
  - [ ] Return `RulesResult` with final_price and applied_rules

- [ ] Task 8: Write tests
  - [ ] Test price cap enforcement
  - [ ] Test loyalty discount calculation
  - [ ] Test rule priority ordering

## Dev Notes

### Rules Configuration Format
```yaml
# backend/src/rules/config.yaml
rules:
  - id: price_floor
    name: "Minimum Price Floor"
    priority: 1
    condition:
      type: always
    action:
      type: floor
      value: "cost * 1.10"  # 10% minimum margin
    
  - id: surge_cap_general
    name: "General Surge Cap"
    priority: 2
    condition:
      type: always
    action:
      type: cap
      value: "cost * 3.0"  # Max 3x surge
      
  - id: surge_cap_rural
    name: "Rural Fairness Cap"
    priority: 3
    condition:
      field: location_category
      operator: equals
      value: "Rural"
    action:
      type: cap
      value: "cost * 1.5"  # Max 1.5x for rural
      
  - id: loyalty_discount
    name: "Loyalty Tier Discount"
    priority: 10  # Apply last
    condition:
      type: always
    action:
      type: discount
      values:
        Bronze: 0.0
        Silver: 0.05
        Gold: 0.10
        Platinum: 0.15
```

### RulesEngine Interface
```python
class RulesEngine:
    def __init__(self, config_path: str = "src/rules/config.yaml"):
        self.rules = self._load_rules(config_path)
    
    def apply(
        self, 
        context: MarketContext, 
        optimal_price: float
    ) -> RulesResult:
        """Apply all rules in priority order"""
        
class RulesResult(BaseModel):
    original_price: float
    final_price: float
    applied_rules: list[AppliedRule]
    total_adjustment: float
    
class AppliedRule(BaseModel):
    rule_id: str
    rule_name: str
    price_before: float
    price_after: float
    impact: float  # Absolute change
    impact_percent: float
```

### Rule Application Order
1. Price Floor (ensure minimum margin)
2. General Surge Cap
3. Segment-Specific Caps (fairness)
4. Loyalty Discounts (always last)

### Testing

- Test file: `backend/tests/unit/test_rules/test_engine.py`
- Test floor prevents below-cost pricing
- Test cap limits excessive surge
- Test loyalty discounts apply correctly
- Test rule ordering (floor before cap before discount)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-02 | 1.0 | Initial story creation | SM Agent |

## Dev Agent Record

### Agent Model Used
(To be filled by Dev Agent)

### Debug Log References
(To be filled by Dev Agent)

### Completion Notes List
(To be filled by Dev Agent)

### File List
(To be filled by Dev Agent)

## QA Results
(To be filled by QA Agent)

