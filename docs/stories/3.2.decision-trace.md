# Story 3.2: Decision Trace Generation

## Status: Ready for Review

## Assigned To: Mario

## Story

**As a** pricing analyst,
**I want** a step-by-step trace of how the system arrived at a price,
**so that** I can audit decisions.

## Acceptance Criteria

1. Trace captures complete pipeline: Input → Segment → External Factors → Model Prediction → Optimization → Rules → Final Price
2. Each step includes: timestamp, duration (ms), input values, output values
3. Trace exportable as JSON (API response) and formatted text (for display)
4. Model agreement indicator: shows if all models agree within 10% or diverge
5. Trace stored for audit purposes (optional file logging)

## Tasks / Subtasks

- [x] Task 1: Create decision trace module (AC: 1)
  - [x] Create `backend/src/explainability/decision_trace.py`
  - [x] Create `DecisionTracer` class
  - [x] Define trace step structure

- [x] Task 2: Implement step tracking (AC: 2)
  - [x] Create `TraceStep` dataclass
  - [x] Include timestamp, duration_ms, inputs, outputs
  - [x] Use context manager or decorator pattern

- [x] Task 3: Integrate with pricing pipeline (AC: 1)
  - [x] Trace segment classification step
  - [x] Trace external factors retrieval
  - [x] Trace model prediction step
  - [x] Trace optimization step
  - [x] Trace rules application step

- [x] Task 4: Calculate model agreement (AC: 4)
  - [x] Get predictions from all 3 models
  - [x] Calculate max deviation percentage
  - [x] Agreement if all within 10%

- [x] Task 5: Create export formats (AC: 3)
  - [x] JSON format for API response
  - [x] Formatted text for display
  - [x] Include all steps and timing

- [x] Task 6: Optional audit logging (AC: 5)
  - [x] Log trace to file if configured
  - [x] Include request ID for correlation
  - [x] Configurable log level

- [x] Task 7: Write tests
  - [x] Test all steps captured
  - [x] Test duration calculation
  - [x] Test model agreement calculation

## Dev Notes

### TraceStep Schema
```python
class TraceStep(BaseModel):
    step_name: str  # "segment_classification"
    timestamp: datetime
    duration_ms: float
    inputs: dict[str, Any]
    outputs: dict[str, Any]
    status: Literal["success", "error", "skipped"]
    error_message: str | None = None

class DecisionTrace(BaseModel):
    trace_id: str  # UUID
    request_timestamp: datetime
    total_duration_ms: float
    steps: list[TraceStep]
    model_agreement: ModelAgreement
    final_result: dict[str, Any]
    
class ModelAgreement(BaseModel):
    models_compared: list[str]
    predictions: dict[str, float]
    max_deviation_percent: float
    is_agreement: bool  # True if all within 10%
    status: Literal["full_agreement", "partial_agreement", "divergent"]
```

### Decorator Pattern for Tracing
```python
from functools import wraps
import time

class DecisionTracer:
    def __init__(self):
        self.steps: list[TraceStep] = []
        self.trace_id = str(uuid.uuid4())
        self.start_time = datetime.now()
    
    def trace_step(self, step_name: str):
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                start = time.perf_counter()
                try:
                    result = func(*args, **kwargs)
                    duration = (time.perf_counter() - start) * 1000
                    self.steps.append(TraceStep(
                        step_name=step_name,
                        timestamp=datetime.now(),
                        duration_ms=duration,
                        inputs={"args": str(args)},
                        outputs={"result": str(result)},
                        status="success"
                    ))
                    return result
                except Exception as e:
                    duration = (time.perf_counter() - start) * 1000
                    self.steps.append(TraceStep(
                        step_name=step_name,
                        timestamp=datetime.now(),
                        duration_ms=duration,
                        inputs={"args": str(args)},
                        outputs={},
                        status="error",
                        error_message=str(e)
                    ))
                    raise
            return wrapper
        return decorator
```

### Pipeline Steps to Trace
1. `input_validation` - Validate MarketContext
2. `segment_classification` - Classify into segment
3. `external_factors` - Fetch weather/events/fuel
4. `demand_prediction` - ML model prediction
5. `price_optimization` - Find optimal price
6. `rules_application` - Apply business rules
7. `explanation_generation` - Generate explanations

### Formatted Text Output
```text
=== Decision Trace: abc-123-def ===
Request Time: 2024-12-02T10:15:30Z
Total Duration: 1,234ms

Step 1: Input Validation (15ms) ✓
  Input: MarketContext(location=Urban, vehicle=Premium, ...)
  Output: Valid

Step 2: Segment Classification (45ms) ✓
  Input: Processed features
  Output: Segment "Urban_Peak_Premium"

Step 3: External Factors (120ms) ✓
  Input: Location coordinates
  Output: Weather=rainy (+15%), Events=none

...

Model Agreement: FULL (max deviation 3.2%)
  - XGBoost: $42.50
  - Random Forest: $43.10
  - Linear Regression: $41.80

Final Price: $42.50
```

### Testing

- Test file: `backend/tests/unit/test_explainability/test_decision_trace.py`
- Test all 7 steps captured
- Test duration_ms > 0 for each step
- Test model agreement calculation

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2024-12-02 | 1.0 | Initial story creation | SM Agent |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (James, Full Stack Developer)

### Debug Log References
- `pytest tests/unit/test_explainability/test_decision_trace.py -v` → 28 passed
- `pytest tests/unit/test_services/test_traced_pricing.py -v` → 13 passed
- `pytest --tb=short -q` → 348 passed (full regression)

### Completion Notes List
1. Created `DecisionTracer` class with decorator pattern for tracing function calls
2. Implemented `TraceStep`, `ModelAgreement`, and `DecisionTrace` Pydantic models
3. Added `calculate_model_agreement()` function for comparing model predictions (10% threshold)
4. Added `format_trace_text()` for human-readable trace output
5. Created `TracedPricingService` that wraps pricing pipeline with 7 traced steps:
   - input_validation, segment_classification, external_factors, demand_prediction, price_optimization, rules_application, explanation_generation
6. Implemented optional audit logging via `_log_trace_to_file()` (controlled by settings.debug)
7. All 41 new tests passing; 348 total tests pass (no regressions)

### File List
| File | Status |
|------|--------|
| `backend/src/explainability/decision_trace.py` | Created |
| `backend/src/explainability/__init__.py` | Modified |
| `backend/src/services/traced_pricing.py` | Created |
| `backend/src/services/__init__.py` | Modified |
| `backend/tests/unit/test_explainability/test_decision_trace.py` | Created |
| `backend/tests/unit/test_services/test_traced_pricing.py` | Created |

## QA Results

### Review Date: 2025-12-02

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: GOOD** — Well-structured implementation with comprehensive documentation and thorough test coverage. The decision trace module provides clean abstractions for pipeline tracing with proper error handling.

**Strengths:**
- Excellent docstrings and type hints throughout
- Pydantic models with field validation and descriptions
- Clean decorator pattern for step tracing
- Safe JSON serialization handling edge cases
- Full error capture at each pipeline step

### Compliance Check

- Coding Standards: ✓ Follows backend standards (snake_case, proper imports, docstrings)
- Project Structure: ✓ Files in correct locations (`explainability/`, `services/`)
- Testing Strategy: ✓ Unit + integration tests following pyramid
- All ACs Met: ✓ All 5 acceptance criteria fully implemented

### Improvements Checklist

- [x] All 7 pipeline steps captured in correct order
- [x] Each step has timestamp, duration_ms, inputs, outputs
- [x] JSON export via `model_dump_json()`
- [x] Text export via `format_trace_text()`
- [x] Model agreement with 10% threshold
- [x] Optional file logging via config
- [ ] Consider migrating `datetime.utcnow()` to `datetime.now(UTC)` (deprecated in Python 3.12+)
- [ ] Move inline `import math` to module level in `traced_pricing.py`

### Security Review

No concerns. Safe serialization prevents injection attacks. File logging uses controlled paths.

### Performance Considerations

Tracing overhead is minimal (measured <1ms per step). No blocking I/O in critical path.

### Files Modified During Review

None — code quality is acceptable for release.

### Gate Status

Gate: PASS → docs/qa/gates/3.2-decision-trace.yml

### Recommended Status

✓ Ready for Done

