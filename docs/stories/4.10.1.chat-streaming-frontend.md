# Story 4.10.1: Chat Streaming Frontend Integration

## Status: Done

## Assigned To: David

## Story

**As a** pricing analyst,
**I want** to see AI responses appear token-by-token in real-time,
**so that** I have immediate feedback that the system is working and can read responses as they generate.

## Acceptance Criteria

1. Chat service updated to handle SSE streaming from `/api/v1/chat`
2. Messages render progressively as tokens arrive (typewriter effect)
3. Tool call indicators shown when agent invokes backend tools
4. Typing indicator replaced by actual streaming content
5. Error handling for stream interruptions with retry option
6. Smooth transition from streaming to complete message
7. Non-streaming fallback if SSE connection fails
8. Keepalive-safe: ignore empty keepalive payloads (e.g., `{}`) and SSE comment lines (`: keepalive`)
9. Orchestrator-ready: pass through `plan=true` (and optional `model=`) and render tool/worker progress unobtrusively

## Tasks / Subtasks

- [x] Task 1: Update chat service for SSE (AC: 1)

  - [x] Modify `frontend/src/services/chatService.ts`
  - [x] Implement `EventSource` or `fetch` with ReadableStream
  - [x] Parse SSE `data:` events
  - [x] Handle connection lifecycle (open, message, error, close)

- [x] Task 2: Create streaming message state (AC: 2, 6)

  - [x] Update `frontend/src/stores/chatStore.ts`
  - [x] Add `streamingMessage: string | null` state
  - [x] Add `appendToStreaming(token: string)` action
  - [x] Add `finalizeStreaming()` action to convert to complete message

- [x] Task 3: Update AIMessage for streaming (AC: 2)

  - [x] Modify `frontend/src/components/chat/AIMessage.tsx`
  - [x] Accept `isStreaming` prop
  - [x] Render partial content with cursor indicator
  - [x] Smooth CSS transition for new tokens

- [x] Task 4: Create tool call indicator (AC: 3)

  - [x] Create `frontend/src/components/chat/ToolCallIndicator.tsx`
  - [x] Display tool name being called (e.g., "üîß Calling optimize_price...")
  - [x] Animate while tool executes
  - [x] Collapse/fade when tool completes

- [x] Task 5: Update ChatPanel orchestration (AC: 2, 4, 6)

  - [x] Modify `frontend/src/components/chat/ChatPanel.tsx`
  - [x] Replace typing indicator with streaming message when tokens arrive
  - [x] Show ToolCallIndicator during tool execution
  - [x] Handle stream completion

- [x] Task 6: Implement error handling (AC: 5, 7)

  - [x] Detect stream disconnection
  - [x] Show "Connection lost" message with retry button
  - [x] Implement retry logic with exponential backoff
  - [x] Fall back to non-streaming if SSE fails 3 times

- [x] Task 7: Add streaming visual polish (AC: 2, 6)

  - [x] Add blinking cursor at end of streaming text
  - [x] Smooth scroll as content grows
  - [x] Fade out cursor on completion
  - [x] Match typing speed to token arrival

- [x] Task 8: Write tests
  - [x] Test SSE parsing
  - [x] Test progressive rendering
  - [x] Test error recovery
  - [x] Test store state transitions

## Dev Notes

### SSE Event Format (Backend v1)

```
data: {"token": "The ", "done": false}

data: {"token": "optimal ", "done": false}

data: {"tool_call": "optimize_price", "done": false}

data: {"token": "price is $24.50", "done": false}

data: {"message": "...", "tools_used": ["optimize_price"], "done": true}

// Optional keepalive (comment line) when enabled
: keepalive

// Some environments may emit an empty data object as keepalive
data: {}
```

### Updated Chat Service (POST + streamed body)

```typescript
// services/chatService.ts
export type ChatStreamEvent =
  | { token: string; done: false }
  | { tool_call: string; done: false }
  | { message: string; tools_used?: string[]; done: true }
  | { error: string; done: true }
  | Record<string, never>; // keepalive `{}` (ignored)

interface StreamOptions {
  plan?: boolean; // orchestrator path
  keepalive?: boolean; // enable backend heartbeats
  interval?: number; // keepalive seconds
  model?: string; // optional reporter model hint
  signal?: AbortSignal; // for cancel
}

export async function* streamMessage(
  message: string,
  context: MarketContext,
  opts: StreamOptions = {}
): AsyncGenerator<ChatStreamEvent> {
  const q = new URLSearchParams({ stream: "true" });
  if (opts.plan) q.set("plan", "true");
  if (opts.keepalive) q.set("keepalive", "true");
  if (opts.interval) q.set("interval", String(opts.interval));
  if (opts.model) q.set("model", opts.model);

  const res = await fetch(`${API_URL}/api/v1/chat?${q.toString()}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "text/event-stream",
    },
    body: JSON.stringify({ message, context }),
    signal: opts.signal,
  });
  if (!res.ok || !res.body)
    throw new Error(`SSE response error: ${res.status}`);

  const reader = res.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    buffer += decoder.decode(value, { stream: true });

    // Split by double newline between events; keep last partial in buffer
    const events = buffer.split("\n\n");
    buffer = events.pop() ?? "";

    for (const raw of events) {
      // Ignore comment lines (e.g., ": keepalive")
      if (raw.startsWith(":")) continue;

      // Handle multi-line data: take last data: line (simple backend emits single data line per event)
      const dataLine = raw.split("\n").find((l) => l.startsWith("data: "));
      if (!dataLine) continue;
      const jsonText = dataLine.slice(6).trim();
      if (!jsonText) continue;

      // Some keepalives are `{}` ‚Äî ignore
      const evt = JSON.parse(jsonText) as ChatStreamEvent;
      if (Object.keys(evt).length === 0) continue;

      yield evt;
      if ((evt as any).done === true) return;
    }
  }
}
```

### Updated Chat Store

```typescript
// stores/chatStore.ts
interface ChatState {
  messages: Message[];
  isLoading: boolean;
  streamingContent: string | null;
  currentToolCall: string | null;
  // ... existing

  startStreaming: () => void;
  appendToken: (token: string) => void;
  setToolCall: (toolName: string | null) => void;
  finalizeStream: (fullMessage: Message) => void;
}
```

### Streaming AIMessage

```tsx
// AIMessage.tsx updates
interface AIMessageProps {
  message: Message;
  isStreaming?: boolean;
}

export function AIMessage({ message, isStreaming }: AIMessageProps) {
  return (
    <div className="flex justify-start">
      <div className="max-w-[80%] bg-muted rounded-2xl rounded-tl-sm px-4 py-2">
        <ReactMarkdown>{message.content}</ReactMarkdown>
        {isStreaming && (
          <span className="inline-block w-2 h-4 bg-primary animate-pulse ml-1" />
        )}
        {!isStreaming && message.confidence && (
          <ConfidenceBadge value={message.confidence} />
        )}
      </div>
    </div>
  );
}
```

### Tool Call Indicator

```tsx
// ToolCallIndicator.tsx
export function ToolCallIndicator({ toolName }: { toolName: string }) {
  const toolLabels: Record<string, string> = {
    optimize_price: "üí∞ Calculating optimal price...",
    explain_decision: "üîç Analyzing decision factors...",
    sensitivity_analysis: "üìä Running sensitivity analysis...",
    get_segment: "üì¶ Identifying segment...",
  };

  return (
    <div className="flex items-center gap-2 text-sm text-muted-foreground py-2">
      <div className="w-4 h-4 border-2 border-primary border-t-transparent rounded-full animate-spin" />
      <span>{toolLabels[toolName] || `üîß Calling ${toolName}...`}</span>
    </div>
  );
}
```

### ChatPanel Streaming Integration

```tsx
// ChatPanel.tsx - streaming flow
const handleSend = async (message: string, plan = false) => {
  addMessage({ role: "user", content: message });
  startStreaming();
  setToolCall(null);
  const ctrl = new AbortController();

  try {
    for await (const event of streamMessage(message, context, {
      plan,
      keepalive: true,
      interval: 15,
      signal: ctrl.signal,
    })) {
      if (event.token) {
        appendToken(event.token);
      }
      if (event.tool_call) {
        setToolCall(event.tool_call);
      }
      if (event.done) {
        finalizeStream({
          role: "assistant",
          content: event.message,
          confidence: event.confidence,
          toolsUsed: event.tools_used,
        });
      }
    }
  } catch (error) {
    // Handle error, offer retry
  }
};
```

### Orchestrator‚ÄëAware UX (Sub‚ÄëAgents)

- Surface a simple toggle or intent selector to run the orchestrator path:
  - ‚ÄúSimple answer (fast)‚Äù ‚Üí omit `plan`
  - ‚ÄúPlan / Analyze (multi‚Äëstep)‚Äù ‚Üí add `plan=true`
- When `tool_call` arrives, render ToolCallIndicator with a compact label. Do not block token rendering.
- Final event includes `tools_used` array ‚Äî display a small footer (‚ÄúUsed: optimize_price, explain_decision‚Äù).
- If you add route‚Äëlevel hints later (e.g., `node`), they can be shown as subtle step chips (‚Äúpolicy ‚Üí reporter‚Äù).

### Keepalive Handling

- When `keepalive=true` is requested, the backend may send:
  - SSE comment lines: `: keepalive` ‚Üí ignore in parser
  - Empty data events: `{}` ‚Üí ignore (already in code)
- Do not append keepalive to the UI; treat it only as a connection liveness signal.
- If you see no real events for > N seconds even with keepalive, show a small ‚ÄúWorking‚Ä¶‚Äù status but keep the stream open.

### Testing

- Test file: `frontend/tests/unit/chat/streaming.test.ts`
- Mock SSE responses (including keepalive comment lines and empty `{}` events)
- Test token accumulation ‚Üí finalization
- Test tool_call rendering hooks
- Test error recovery fallback

Example (Vitest/Jest)

```ts
// frontend/tests/unit/chat/streaming.test.ts
import { describe, it, expect, vi } from "vitest";
import { streamMessage } from "@/services/chatService";

const encoder = new TextEncoder();

function makeSSEStream(chunks: string[]): ReadableStream<Uint8Array> {
  return new ReadableStream<Uint8Array>({
    start(controller) {
      for (const c of chunks) controller.enqueue(encoder.encode(c));
      controller.close();
    },
  });
}

describe("streamMessage SSE parsing", () => {
  it("handles tokens, tool_call, keepalive, and final message", async () => {
    const frames = [
      'data: {"token": "The ", "done": false}\n\n',
      ": keepalive\n\n",
      "data: {}\n\n", // empty keepalive payload
      'data: {"tool_call": "optimize_price", "done": false}\n\n',
      'data: {"token": "answer", "done": false}\n\n',
      'data: {"message": "Final.", "tools_used": ["optimize_price"], "done": true}\n\n',
    ];

    // Mock fetch to return our SSE stream
    vi.stubGlobal(
      "fetch",
      vi.fn(
        async () =>
          ({
            ok: true,
            body: makeSSEStream(frames),
          } as unknown as Response)
      )
    );

    const events: any[] = [];
    for await (const evt of streamMessage(
      "q",
      {
        number_of_riders: 50,
        number_of_drivers: 25,
        location_category: "Urban",
        customer_loyalty_status: "Gold",
        number_of_past_rides: 20,
        average_ratings: 4.5,
        time_of_booking: "Evening",
        vehicle_type: "Premium",
        expected_ride_duration: 30,
        historical_cost_of_ride: 35.0,
      },
      { plan: true, keepalive: true, interval: 15 }
    )) {
      events.push(evt);
    }

    // Should include token and tool_call, and end with done
    expect(events.some((e) => e.token === "The ")).toBe(true);
    expect(events.some((e) => e.tool_call === "optimize_price")).toBe(true);
    const last = events.at(-1);
    expect(last.done).toBe(true);
    expect(last.message).toBe("Final.");
    expect(last.tools_used).toEqual(["optimize_price"]);
  });
});
```

## Dependencies

- **Requires Stories 4.9.1 / 4.9.2** (Backend streaming + orchestrator) to be complete. Use `plan=true` for multi‚Äëagent flows.
- Built on top of Story 4.3 (Center Panel Chat) components

## Change Log

| Date       | Version | Description                                                   | Author         |
| ---------- | ------- | ------------------------------------------------------------- | -------------- |
| 2024-12-02 | 1.0     | Initial story creation - Frontend streaming integration       | SM Agent (Bob) |
| 2025-12-03 | 1.1     | Added keepalive handling and orchestrator params (plan/model) | Dev Agent      |
| 2025-12-03 | 1.2     | Added FE SSE parser test and usage examples                   | Dev Agent      |

## Usage Examples

- Simple (single‚Äëagent fast path):

```ts
for await (const evt of streamMessage("What is the optimal price?", ctx)) {
  // handle token/tool_call/final
}
```

- Orchestrator plan with model hint and keepalive:

```ts
for await (const evt of streamMessage(
  "Propose a price and summarize for leadership.",
  ctx,
  { plan: true, model: "gpt-4o-mini", keepalive: true, interval: 15 }
)) {
  // handle events
}
```

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (via Cursor)

### Debug Log References

- `bun test tests/unit/chat/streaming.test.ts` - 15 tests pass
- `bun test tests/unit/chat/` - 22 tests pass (including existing)
- `bun test` - Full suite: 182 tests pass, 0 fail

### Completion Notes List

1. **Task 1**: Implemented `streamMessage` async generator with SSE parsing, keepalive handling (comment lines and empty `{}`), and orchestrator params (plan, model, keepalive, interval)
2. **Task 2**: Extended chatStore with streaming state (`streamingContent`, `currentToolCall`, `streamError`) and actions (`startStreaming`, `appendToken`, `setToolCall`, `finalizeStream`, `cancelStream`, `setStreamError`)
3. **Task 3**: Updated AIMessage with `isStreaming` prop and blinking cursor indicator using custom CSS animation
4. **Task 4**: Created ToolCallIndicator component with human-readable labels for common tools and animated spinner
5. **Task 5**: Refactored ChatPanel to use streaming flow with abort controller support and tool call handling
6. **Task 6**: Added StreamError component with retry button, fallback to non-streaming after 3 consecutive failures
7. **Task 7**: Added custom CSS animations in globals.css for cursor pulse, tool spinner, and message slide-in
8. **Task 8**: Created comprehensive test suite with 15 tests covering store state transitions, SSE parsing (including keepalive), and error handling

### File List

| File                                                 | Action                                                                 |
| ---------------------------------------------------- | ---------------------------------------------------------------------- |
| `frontend/src/services/chatService.ts`               | Modified - Added `ChatStreamEvent`, `StreamOptions`, `streamMessage()` |
| `frontend/src/stores/chatStore.ts`                   | Modified - Added streaming state and actions                           |
| `frontend/src/components/chat/AIMessage.tsx`         | Modified - Added `isStreaming` prop and cursor                         |
| `frontend/src/components/chat/ToolCallIndicator.tsx` | Created - Tool call indicator component                                |
| `frontend/src/components/chat/StreamError.tsx`       | Created - Error display with retry button                              |
| `frontend/src/components/chat/ChatPanel.tsx`         | Modified - Streaming flow with error handling                          |
| `frontend/src/components/chat/MessageList.tsx`       | Modified - Support streaming content and errors                        |
| `frontend/src/components/chat/index.ts`              | Modified - Export new components                                       |
| `frontend/src/app/globals.css`                       | Modified - Added streaming animations                                  |
| `frontend/tests/unit/chat/streaming.test.ts`         | Created - 15 tests for streaming functionality                         |

### Change Log

| Date       | Version | Description                                     | Author            |
| ---------- | ------- | ----------------------------------------------- | ----------------- |
| 2025-12-04 | 1.3     | Implemented all streaming tasks, 182 tests pass | Dev Agent (James) |

## QA Results

### Review Date: 2025-01-04

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: EXCELLENT** ‚Äî This is a high-quality implementation of SSE streaming functionality. The code demonstrates strong software engineering practices:

1. **Architecture**: Clean separation of concerns with streaming logic in service, state in store, and rendering in components
2. **TypeScript**: Strong typing throughout with proper discriminated unions for `ChatStreamEvent`
3. **Error Handling**: Comprehensive ‚Äî handles abort, network errors, malformed JSON, and connection loss
4. **Resilience**: Smart fallback to non-streaming after 3 consecutive failures
5. **UX Polish**: Blinking cursor, tool call indicators, and smooth animations enhance user experience

### Requirements Traceability

| AC  | Description                            | Test Coverage                                                         | Status     |
| --- | -------------------------------------- | --------------------------------------------------------------------- | ---------- |
| AC1 | Chat service updated for SSE streaming | `SSE Parsing` test suite (6 tests)                                    | ‚úÖ COVERED |
| AC2 | Progressive token rendering            | `appendToken`, `finalizeStream` store tests + `AIMessage.isStreaming` | ‚úÖ COVERED |
| AC3 | Tool call indicators                   | `ToolCallIndicator` component + `setToolCall` store action            | ‚úÖ COVERED |
| AC4 | Typing indicator replaced by streaming | `MessageList` conditional rendering logic                             | ‚úÖ COVERED |
| AC5 | Error handling with retry              | `StreamError` component + `handleRetry` + `setStreamError` tests      | ‚úÖ COVERED |
| AC6 | Smooth transition to complete message  | `finalizeStream` action clears state atomically                       | ‚úÖ COVERED |
| AC7 | Non-streaming fallback                 | `MAX_STREAM_FAILURES` + `useStreaming` state toggle                   | ‚úÖ COVERED |
| AC8 | Keepalive handling                     | Tests for comment lines (`: keepalive`) and empty `{}` payloads       | ‚úÖ COVERED |
| AC9 | Orchestrator-ready with `plan=true`    | `StreamOptions.plan` parameter + query string building                | ‚úÖ COVERED |

### Test Architecture Assessment

**Excellent test coverage:**

- 15 dedicated streaming tests
- 7 chat store state tests
- 6 SSE parsing tests (including keepalive scenarios)
- 2 error handling tests

**Test Quality:**

- Good mocking of `fetch` for SSE streams
- Proper isolation with `beforeEach` state reset
- Tests cover happy path, edge cases (keepalive, `[DONE]`), and error scenarios

### Compliance Check

- Coding Standards: ‚úÖ Follows project conventions, uses Bun test runner, proper TypeScript
- Project Structure: ‚úÖ Components in `chat/`, service in `services/`, store in `stores/`
- Testing Strategy: ‚úÖ Unit tests with good coverage following the testing pyramid
- All ACs Met: ‚úÖ All 9 acceptance criteria have corresponding implementation and tests

### Improvements Checklist

- [x] SSE parsing handles keepalive comment lines
- [x] SSE parsing handles empty `{}` payloads
- [x] Exponential backoff / fallback after 3 failures
- [x] Reader lock released in `finally` block (line 166-167)
- [x] Abort signal properly handled
- [ ] **Nice-to-have**: Consider adding integration test with real backend SSE endpoint
- [ ] **Nice-to-have**: Add E2E test for full streaming flow with Playwright

### Security Review

**Status: PASS** ‚Äî No security concerns identified:

- No sensitive data exposed in streaming content
- Proper error messages (no stack traces leaked)
- Uses standard `fetch` API with proper headers

### Performance Considerations

**Status: PASS** ‚Äî Implementation is performant:

- Efficient buffer-based SSE parsing (no regex per character)
- Reader lock properly released in `finally` block
- State updates are atomic (no intermediate renders during token append)
- CSS animations use GPU-accelerated properties (`opacity`, `transform`)

### Files Modified During Review

No modifications made ‚Äî code quality meets standards.

### Gate Status

**Gate: PASS** ‚Üí `docs/qa/gates/4.10.1-chat-streaming-frontend.yml`

### Recommended Status

‚úÖ **Ready for Done**

The implementation is complete, well-tested (15 streaming-specific tests, 182 total tests passing), and follows all project standards. All 9 acceptance criteria are met with corresponding test coverage.
